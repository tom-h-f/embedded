#include <unistd.h>
#include <stdio.h>
#include <inttypes.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "esp_heap_caps.h"
#include "esp_lcd_panel_ops.h"
#include "LCD_Driver/ST7789.h"
#include "esp_log.h"

/* Simple 5x7 font and helpers (same as before) */
#define RGB565(r,g,b) ((((r) & 0xF8) << 8) | (((g) & 0xFC) << 3) | (((b) & 0xF8) >> 3))

extern esp_lcd_panel_handle_t panel_handle;

static void fill_rect(esp_lcd_panel_handle_t panel, int x, int y, int w, int h, uint16_t color)
{
    if (w <= 0 || h <= 0) return;
    size_t size = (size_t)w * h * sizeof(uint16_t);
    uint16_t *buf = heap_caps_malloc(size, MALLOC_CAP_DMA);
    if (!buf) return;
    for (size_t i = 0; i < (size / sizeof(uint16_t)); ++i) buf[i] = color;
    esp_lcd_panel_draw_bitmap(panel, x, y, x + w - 1, y + h - 1, buf);
    free(buf);
}

static void draw_embedded_bmp(esp_lcd_panel_handle_t panel);

void app_main(void)
{
    printf("Hello — initializing LCD driver...\n");
    LCD_Init();
    BK_Light(20);

    /* Draw some colored bands */
    uint16_t red = RGB565(255,0,0);
    uint16_t green = RGB565(0,255,0);
    uint16_t blue = RGB565(0,0,255);
    uint16_t yellow = RGB565(255,255,0);
    uint16_t white = RGB565(255,255,255);

    if (!panel_handle) {
        printf("panel_handle is NULL — aborting drawing\n");
        return;
    }
    fill_rect(panel_handle, 0, 0, EXAMPLE_LCD_H_RES+80, EXAMPLE_LCD_V_RES+80,white);

    /* Draw embedded bitmap (if present) */
    draw_embedded_bmp(panel_handle);

    printf("Drawing complete.\n");
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/* Embedded BMP access - symbols generated by objcopy when using EMBED_FILES
   File: main/house.bmp -> symbols: _binary_house_bmp_start/_end/_size
*/
extern const uint8_t _binary_house_bmp_start[] asm("_binary_house_bmp_start");
extern const uint8_t _binary_house_bmp_end[]   asm("_binary_house_bmp_end");

static void draw_embedded_bmp(esp_lcd_panel_handle_t panel)
{
    const uint8_t *bmp = _binary_house_bmp_start;
    size_t len = (size_t)(_binary_house_bmp_end - _binary_house_bmp_start);
    if (len < 54) return; // not a valid BMP

    uint32_t data_offset = bmp[10] | (bmp[11] << 8) | (bmp[12] << 16) | (bmp[13] << 24);
    int32_t width  = bmp[18] | (bmp[19] << 8) | (bmp[20] << 16) | (bmp[21] << 24);
    int32_t height = bmp[22] | (bmp[23] << 8) | (bmp[24] << 16) | (bmp[25] << 24);
    uint16_t bpp   = bmp[28] | (bmp[29] << 8);
    ESP_LOGI("BVR", "BMP image: %dx%d, bpp=%d, data_offset=%d", width, height, bpp, data_offset);
    if (width <= 0 || height <= 0 || bpp != 24) return;

    int row_bytes = ((width * 3 + 3) / 4) * 4; // padded to 4 bytes
    size_t pixel_count = (size_t)width * (size_t)height;
    uint16_t *buf = heap_caps_malloc(pixel_count * sizeof(uint16_t), MALLOC_CAP_DMA);
    if (!buf) return;

    const uint8_t *pixstart = bmp + data_offset;
    for (int y = 0; y < height; ++y) {
        const uint8_t *row = pixstart + (size_t)(height - 1 - y) * row_bytes;
        for (int x = 0; x < width; ++x) {
            uint8_t b = row[x*3 + 0];
            uint8_t g = row[x*3 + 1];
            uint8_t r = row[x*3 + 2];
            uint16_t pix = (uint16_t)((((r & 0xF8) << 8) | ((g & 0xFC) << 3) | ((b & 0xF8) >> 3)));
            buf[y * width + x] = pix;
        }
    }

    esp_lcd_panel_draw_bitmap(panel, 0, 0, width, height, buf);
    free(buf);
}
